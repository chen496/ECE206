% In last part, we discussed how to generate signals by discrete-time
% time supports.
% To approximate continuous-time signals, we generate discrete time
% supports and their corresponding signal outputs, and then, plot out
% discrete signal points on proper range of time. But obviously, this 
% method is not a very efficient method, and sometimes the numeric
% approximation will encounter precision problem.
% And today, I will give u more examples of generating signals by Symbolic.
% And these signal may be peroidic and infinite. So in these cases, 
% select proper time of one cycle is important.
% For example, if our signal y(t) = sin(t). This is a simple sinusoid function, 
% whose cycle is 2\pi. Therefore, we only need plot time cycle span from 0 
% to 2\pi is enough, and then, rest of signals is just repeat of this
% cycle.
% Then, let us consider a much more complicated example, a periodic pulse 
% generated by adding three cosine functions. 
% Assuming that we have \omega_0 = \pi/10. Then we will have
% x(t) = 1 + 1.5cos(2\omega_0t) - 0.6cos(4\omega_0t)
% For sine/cosion functins of (\omega t + a), we always have the cycle period always equals 
% to 2\pi/\omega, then we have T(1.5cos(2\omega_0t)) = 10 and 
% T(0.6cos(4\omega_0t)) = 5,  then, for summation of these sin/cos
% functions, we have their T(x(t)) = max(T(.)) = 10. Thereofore, we can
% easily select t \in [0, 10] can be used to represent 1 cycle.
% In addition, the usage of symbolic operation is as same as our
% introduction.
clear; clf;
t = sym('t');
% easily generate by formula
x = 1 + 1.5 * cos(2 * pi * t / 10) - 0.6 * cos(4 * pi * t / 10);
% since the period is 10, so we can plot 1 cycle in [0, 10)
figure(1)
subplot(211)
ezplot(x, [0, 10]); grid; 
title('$$1 + 1.5\cos(2 * \pi * t / 10) - 0.6\cos(4 * \pi * t / 10)$$', 'interpreter', 'latex');
% Then, to make sure that our cycle calculation is correct, we can plot 2
% cycle as follow
subplot(212)
ezplot(x, [-10, 10]); grid; 
title('$$1 + 1.5\cos(2 * \pi * t / 10) - 0.6\cos(4 * \pi * t / 10)$$', 'interpreter', 'latex');


% Review, how to use the numerical approximation method in last lab to
% finish this? For our function, \omega_0 = \pi/10
% x(t) = 1 + 1.5cos(2\omega_0t) - 0.6cos(4\omega_0t)
% 1  : f = 0 Hz
% 1.5cos(2\omega_0t) : f = 1 / 2 \pi / \omega_0 = 0.2
% 0.6\cos(4 * \pi * t / 10) : f = 1 / 2 \pi /4 \pi / 10 = 0.4
fs = (2*0.2) * 10;
t = -10:1/fs:10;
y = 1 + 1.5 * cos(2 * pi * t / 10) - 0.6 * cos(4 * pi * t / 10);
figure(5);
plot(t, y, 'k');
axis([-10 10 -2 4]);
grid on;
title('$$1 + 1.5\cos(2 * \pi * t / 10) - 0.6\cos(4 * \pi * t / 10)$$', 'interpreter', 'latex');


% Obviously, if we use the symbolic computation in Matlab, it is much
% better for continuous and non-segment signal generation. Because if 
% we use the discrete time supports to generate corresponding signal, 
% it is necessary to prove that how many discrete points we need to 
% recover the original signal perfectly. This is a theory called 
% Nyquist-Shannon sampling theorem, it claims that our sampling rate must be
% greater than 2 times of signal bandwidth. And we will learn this theorem
% later. But before we understand this theorem, we can use symbolic
% computation to bridge the discrete and continuous.
%
% One more example, if our signal is not exactly period, such as 
% damped sinusoid signal, we also can use symbolic computation to complete
% signal generation.
% For damped sinusoid signal, y(t) = e^{-t}cos(2\pi t)
% we can use matlab simulate it and plot its envelope. 
t = sym('t');
x = exp(-t) * cos(2 * pi * t);
y = exp(-t);
figure(2);
ezplot(x, [-2, 4]);
grid;
hold on;  % command keep and stack new element on same figure
ezplot(y, [-2, 4]);
hold on;
ezplot(-y, [-2, 4]);
axis([-2 4 -8 8]);
hold off;

% So, these two are examples using symbolic computation in Matlab to generate
% signal. Ad we also can generate signal from their derivative by symbolic 
% method, let us go back to review the example I showed to you in hello section, we also 
% can generate signal from ordinary differential equation
% For example, we have the signal y(t) is
% d^2 y/dt^2 + 5 d y /dt + 6 y(t) = 1
% Then we can solve the ODE and generate signal y(t) like this
syms y t x z;
% Then we use dsolve to solve this function
y = dsolve('D2y+5*Dy+6*y=1','y(0)=0', 'Dy(0)=0', 't');
x = diff(y);   %% impulse Derivative
z = int(y);    %% ramp Integrates
figure(3);
subplot(311);
fplot(y, [0, 5]); grid; title('Unit-step reponse');
subplot(312);
fplot(x, [0, 5]); grid; title('Impulse response');
subplot(313);
fplot(z, [0, 5]); grid; title('Ramp response');

% Also, we can use Symbolic to integrate several functions like this
% such as int_0^k sin^2(t) dt
zz = zeros(10);
syms t z;
for k = 1:10
   z = 2 * int(sin(t)^2, t, 0, k); % integral of [sin(pi*t)/(pi * t)]^2 on 0 to k
   zz(k) = subs(z);     % subs copy our symbolic result z and store it as a vector element
end
figure(4);
t1 = linspace(-4, 4);
y = 2 * sin(t1).^2;
n = 1:10;
subplot(211)
plot(t1, y); grid;
subplot(212);
stem(n(1:10), zz(1:10)); hold on;
plot(n(1:10), zz(1:10), 'r'); grid;
hold off;

% So, let us go to some examples in time-continuous signal, about the power of 
% an analog signal y(t). Which can be represented as intergate of |x(t)|^2
% P_x = lim_{T->inf}1/2T int_{-T}^T|x(t)|^2dt
% let us consider a Full-wave rectified signal
% y(t) = |sin(\pi t)| T = 2/2 = 1
t = sym('t');
y = abs(sin(pi * t));
figure(5);
ezplot(y, [-2, 4]);
grid;
title('$$y(t) = |sin(\pi t)|$$', 'interpreter', 'latex');

% Above is our observation for Full-wave rectified signal
% And then, we also can use matlab to calculate the limitation of several 
% function.
syms t T;
P = 1 / (2 * T) * int((sin(pi * t))^2, t, -T, T);
limit(P, T, inf)

% Assignment 2.1
% 1. For our Full-wave rectified signal y(t) = |sin(pi * t)|, please find
% out its period T = ?
% 2. Write out the Power expression P_y of this signal y(t);
% 3. Can you find out the bound of |y(t)|^2? And please prove that P_y < 1/
% 4. Follow the example of Symbolic integrate, please use Symbolic matlab
% to plot out the trend of 1/2T * int_{-T}^T |y(t)|^2 dt. Is it coincide
% with the analytical result?




% So if we want to calculate the convolution, we can use the int function
% E.g. we discuss the convolution in Charging RC Circuit
G = @(RC)(@(t) 1 / RC * exp(-t / RC) .* (t >= 0));
h = G(1.0);
u = @(t) t .* (t >= 0 & t < 1) + (2 - t) .* (t >= 1 & t < 2);

delta=0.0001;
l = 10 / delta;
tau = 0:delta:10;
C = conv(h(tau), u(tau)) * delta;
figure(6)
plot(t(1:l), C(1:l)); grid; title('h * u');

% Help document of https://www.mathworks.com/help/matlab/ref/conv.html#bucr92l-2
% w(1) = u(1)*v(1)
% w(2) = u(1)*v(2)+u(2)*v(1)
% w(3) = u(1)*v(3)+u(2)*v(2)+u(3)*v(1)
% w(n) = u(1)*v(n)+u(2)*v(n-1)+ ... +u(n)*v(1)
% w(2*n-1) = u(n)*v(n)

% in symbolic unit-step is heaviside

syms t tau;

y = heaviside(t);

figure(7)
ezplot(y, [-5, 5]);

y = t * heaviside(t) - (2*t - 2) * heaviside(t - 1) + (t - 2) * heaviside(t - 2);

figure(7)
ezplot(y, [-2, 4]);

h = exp(-t) * heaviside(t);
C2 = [];
for tau = 0:0.1:10
    C2 = [C2, double(int(y * exp(t - tau) * heaviside(tau - t), t, 0, tau))];
end

figure(8)
plot(0:1:10, C2)





